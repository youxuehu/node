// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: yeying/api/audit/audit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { MessageHeader, RequestPage, ResponsePage, ResponseStatus } from "../common/message";

export const protobufPackage = "yeying.api.audit";

export enum CommentStatusEnum {
  /** COMMENT_STATUS_AGREE - 通过 */
  COMMENT_STATUS_AGREE = 0,
  /** COMMENT_STATUS_REJECT - 拒绝 */
  COMMENT_STATUS_REJECT = 1,
  UNRECOGNIZED = -1,
}

export function commentStatusEnumFromJSON(object: any): CommentStatusEnum {
  switch (object) {
    case 0:
    case "COMMENT_STATUS_AGREE":
      return CommentStatusEnum.COMMENT_STATUS_AGREE;
    case 1:
    case "COMMENT_STATUS_REJECT":
      return CommentStatusEnum.COMMENT_STATUS_REJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommentStatusEnum.UNRECOGNIZED;
  }
}

export function commentStatusEnumToJSON(object: CommentStatusEnum): string {
  switch (object) {
    case CommentStatusEnum.COMMENT_STATUS_AGREE:
      return "COMMENT_STATUS_AGREE";
    case CommentStatusEnum.COMMENT_STATUS_REJECT:
      return "COMMENT_STATUS_REJECT";
    case CommentStatusEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AuditCreateRequest {
  header: MessageHeader | undefined;
  body: AuditCreateRequestBody | undefined;
}

export interface AuditCreateRequestBody {
  meta: AuditMetadata | undefined;
}

export interface AuditCreateResponse {
  header: MessageHeader | undefined;
  body: AuditCreateResponseBody | undefined;
}

export interface AuditCreateResponseBody {
  status: ResponseStatus | undefined;
  meta: AuditMetadata | undefined;
}

export interface AuditDetailRequest {
  header: MessageHeader | undefined;
  body: AuditDetailRequestBody | undefined;
}

export interface AuditDetailRequestBody {
  uid: string;
}

export interface AuditDetailResponse {
  header: MessageHeader | undefined;
  body: AuditDetailResponseBody | undefined;
}

export interface AuditDetailResponseBody {
  status: ResponseStatus | undefined;
  detail: AuditDetail | undefined;
}

export interface AuditCancelRequest {
  header: MessageHeader | undefined;
  body: AuditCancelRequestBody | undefined;
}

export interface AuditCancelRequestBody {
  uid: string;
}

export interface AuditCancelResponse {
  header: MessageHeader | undefined;
  body: AuditCancelResponseBody | undefined;
}

export interface AuditCancelResponseBody {
  status: ResponseStatus | undefined;
  meta: AuditMetadata | undefined;
}

export interface AuditApproveRequest {
  header: MessageHeader | undefined;
  body: AuditApproveRequestBody | undefined;
}

export interface AuditApproveRequestBody {
  metadata: CommentMetadata | undefined;
}

export interface AuditApproveResponse {
  header: MessageHeader | undefined;
  body: AuditApproveResponseBody | undefined;
}

export interface AuditApproveResponseBody {
  status: ResponseStatus | undefined;
  metadata: CommentMetadata | undefined;
}

export interface AuditRejectRequest {
  header: MessageHeader | undefined;
  body: AuditRejectRequestBody | undefined;
}

export interface AuditRejectRequestBody {
  metadata: CommentMetadata | undefined;
}

export interface AuditRejectResponse {
  header: MessageHeader | undefined;
  body: AuditRejectResponseBody | undefined;
}

export interface AuditRejectResponseBody {
  status: ResponseStatus | undefined;
  metadata: CommentMetadata | undefined;
}

export interface AuditSearchRequest {
  header: MessageHeader | undefined;
  body: AuditSearchRequestBody | undefined;
}

export interface AuditSearchRequestBody {
  condition: AuditSearchCondition | undefined;
  page: RequestPage | undefined;
}

export interface AuditSearchResponse {
  header: MessageHeader | undefined;
  body: AuditSearchResponseBody | undefined;
}

export interface AuditSearchResponseBody {
  status: ResponseStatus | undefined;
  detail: AuditDetail[];
  page: ResponsePage | undefined;
}

export interface AuditDetail {
  meta: AuditMetadata | undefined;
  commentMeta: CommentMetadata[];
}

export interface AuditSearchCondition {
  /** 审批人 */
  approver: string;
  /** 应用/服务名称 */
  name: string;
  /** 申请类型：应用/服务 */
  type: string;
  /** 申请人 */
  applicant: string;
  /** 开始时间 */
  startTime: string;
  /** 结束时间 */
  endTime: string;
}

export interface AuditMetadata {
  /** 主键uid */
  uid: string;
  /** 应用元数据 / 服务元数据序例化 json 字符串 */
  appOrServiceMetadata: string;
  auditType: string;
  /**
   * 申请人身份，存字符串，使用 :: 拼接
   * 拼接格式 did::name
   */
  applicant: string;
  /**
   * 审批人身份：可能有多个人审批人，使用 list json
   * 拼接格式 did::name
   */
  approver: string;
  /** 申请原因 */
  reason: string;
  /** 创建时间 */
  createdAt: string;
  /** 修改时间 */
  updatedAt: string;
  /** 签名 */
  signature: string;
}

/** 审批意见表 */
export interface CommentMetadata {
  /** 主键 id */
  uid: string;
  /** 审计表 id */
  auditId: string;
  /** 审批备注文字 id */
  text: string;
  /** 审批状态 id */
  status: CommentStatusEnum;
  /** 创建时间 */
  createdAt: string;
  /** 修改时间 */
  updatedAt: string;
  /** 签名 */
  signature: string;
}

function createBaseAuditCreateRequest(): AuditCreateRequest {
  return { header: undefined, body: undefined };
}

export const AuditCreateRequest: MessageFns<AuditCreateRequest> = {
  encode(message: AuditCreateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditCreateRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCreateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditCreateRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCreateRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditCreateRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditCreateRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditCreateRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCreateRequest>, I>>(base?: I): AuditCreateRequest {
    return AuditCreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCreateRequest>, I>>(object: I): AuditCreateRequest {
    const message = createBaseAuditCreateRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditCreateRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditCreateRequestBody(): AuditCreateRequestBody {
  return { meta: undefined };
}

export const AuditCreateRequestBody: MessageFns<AuditCreateRequestBody> = {
  encode(message: AuditCreateRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      AuditMetadata.encode(message.meta, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCreateRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCreateRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meta = AuditMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCreateRequestBody {
    return { meta: isSet(object.meta) ? AuditMetadata.fromJSON(object.meta) : undefined };
  },

  toJSON(message: AuditCreateRequestBody): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = AuditMetadata.toJSON(message.meta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCreateRequestBody>, I>>(base?: I): AuditCreateRequestBody {
    return AuditCreateRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCreateRequestBody>, I>>(object: I): AuditCreateRequestBody {
    const message = createBaseAuditCreateRequestBody();
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? AuditMetadata.fromPartial(object.meta)
      : undefined;
    return message;
  },
};

function createBaseAuditCreateResponse(): AuditCreateResponse {
  return { header: undefined, body: undefined };
}

export const AuditCreateResponse: MessageFns<AuditCreateResponse> = {
  encode(message: AuditCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditCreateResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditCreateResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCreateResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditCreateResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditCreateResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditCreateResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCreateResponse>, I>>(base?: I): AuditCreateResponse {
    return AuditCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCreateResponse>, I>>(object: I): AuditCreateResponse {
    const message = createBaseAuditCreateResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditCreateResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditCreateResponseBody(): AuditCreateResponseBody {
  return { status: undefined, meta: undefined };
}

export const AuditCreateResponseBody: MessageFns<AuditCreateResponseBody> = {
  encode(message: AuditCreateResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.meta !== undefined) {
      AuditMetadata.encode(message.meta, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCreateResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCreateResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = AuditMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCreateResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      meta: isSet(object.meta) ? AuditMetadata.fromJSON(object.meta) : undefined,
    };
  },

  toJSON(message: AuditCreateResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.meta !== undefined) {
      obj.meta = AuditMetadata.toJSON(message.meta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCreateResponseBody>, I>>(base?: I): AuditCreateResponseBody {
    return AuditCreateResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCreateResponseBody>, I>>(object: I): AuditCreateResponseBody {
    const message = createBaseAuditCreateResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? AuditMetadata.fromPartial(object.meta)
      : undefined;
    return message;
  },
};

function createBaseAuditDetailRequest(): AuditDetailRequest {
  return { header: undefined, body: undefined };
}

export const AuditDetailRequest: MessageFns<AuditDetailRequest> = {
  encode(message: AuditDetailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditDetailRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditDetailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditDetailRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditDetailRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditDetailRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditDetailRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditDetailRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditDetailRequest>, I>>(base?: I): AuditDetailRequest {
    return AuditDetailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditDetailRequest>, I>>(object: I): AuditDetailRequest {
    const message = createBaseAuditDetailRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditDetailRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditDetailRequestBody(): AuditDetailRequestBody {
  return { uid: "" };
}

export const AuditDetailRequestBody: MessageFns<AuditDetailRequestBody> = {
  encode(message: AuditDetailRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditDetailRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditDetailRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditDetailRequestBody {
    return { uid: isSet(object.uid) ? globalThis.String(object.uid) : "" };
  },

  toJSON(message: AuditDetailRequestBody): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditDetailRequestBody>, I>>(base?: I): AuditDetailRequestBody {
    return AuditDetailRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditDetailRequestBody>, I>>(object: I): AuditDetailRequestBody {
    const message = createBaseAuditDetailRequestBody();
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseAuditDetailResponse(): AuditDetailResponse {
  return { header: undefined, body: undefined };
}

export const AuditDetailResponse: MessageFns<AuditDetailResponse> = {
  encode(message: AuditDetailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditDetailResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditDetailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditDetailResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditDetailResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditDetailResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditDetailResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditDetailResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditDetailResponse>, I>>(base?: I): AuditDetailResponse {
    return AuditDetailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditDetailResponse>, I>>(object: I): AuditDetailResponse {
    const message = createBaseAuditDetailResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditDetailResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditDetailResponseBody(): AuditDetailResponseBody {
  return { status: undefined, detail: undefined };
}

export const AuditDetailResponseBody: MessageFns<AuditDetailResponseBody> = {
  encode(message: AuditDetailResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.detail !== undefined) {
      AuditDetail.encode(message.detail, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditDetailResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditDetailResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.detail = AuditDetail.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditDetailResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      detail: isSet(object.detail) ? AuditDetail.fromJSON(object.detail) : undefined,
    };
  },

  toJSON(message: AuditDetailResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.detail !== undefined) {
      obj.detail = AuditDetail.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditDetailResponseBody>, I>>(base?: I): AuditDetailResponseBody {
    return AuditDetailResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditDetailResponseBody>, I>>(object: I): AuditDetailResponseBody {
    const message = createBaseAuditDetailResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? AuditDetail.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseAuditCancelRequest(): AuditCancelRequest {
  return { header: undefined, body: undefined };
}

export const AuditCancelRequest: MessageFns<AuditCancelRequest> = {
  encode(message: AuditCancelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditCancelRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCancelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCancelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditCancelRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCancelRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditCancelRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditCancelRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditCancelRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCancelRequest>, I>>(base?: I): AuditCancelRequest {
    return AuditCancelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCancelRequest>, I>>(object: I): AuditCancelRequest {
    const message = createBaseAuditCancelRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditCancelRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditCancelRequestBody(): AuditCancelRequestBody {
  return { uid: "" };
}

export const AuditCancelRequestBody: MessageFns<AuditCancelRequestBody> = {
  encode(message: AuditCancelRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCancelRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCancelRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCancelRequestBody {
    return { uid: isSet(object.uid) ? globalThis.String(object.uid) : "" };
  },

  toJSON(message: AuditCancelRequestBody): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCancelRequestBody>, I>>(base?: I): AuditCancelRequestBody {
    return AuditCancelRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCancelRequestBody>, I>>(object: I): AuditCancelRequestBody {
    const message = createBaseAuditCancelRequestBody();
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseAuditCancelResponse(): AuditCancelResponse {
  return { header: undefined, body: undefined };
}

export const AuditCancelResponse: MessageFns<AuditCancelResponse> = {
  encode(message: AuditCancelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditCancelResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCancelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCancelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditCancelResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCancelResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditCancelResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditCancelResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditCancelResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCancelResponse>, I>>(base?: I): AuditCancelResponse {
    return AuditCancelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCancelResponse>, I>>(object: I): AuditCancelResponse {
    const message = createBaseAuditCancelResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditCancelResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditCancelResponseBody(): AuditCancelResponseBody {
  return { status: undefined, meta: undefined };
}

export const AuditCancelResponseBody: MessageFns<AuditCancelResponseBody> = {
  encode(message: AuditCancelResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.meta !== undefined) {
      AuditMetadata.encode(message.meta, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditCancelResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditCancelResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = AuditMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditCancelResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      meta: isSet(object.meta) ? AuditMetadata.fromJSON(object.meta) : undefined,
    };
  },

  toJSON(message: AuditCancelResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.meta !== undefined) {
      obj.meta = AuditMetadata.toJSON(message.meta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditCancelResponseBody>, I>>(base?: I): AuditCancelResponseBody {
    return AuditCancelResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditCancelResponseBody>, I>>(object: I): AuditCancelResponseBody {
    const message = createBaseAuditCancelResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? AuditMetadata.fromPartial(object.meta)
      : undefined;
    return message;
  },
};

function createBaseAuditApproveRequest(): AuditApproveRequest {
  return { header: undefined, body: undefined };
}

export const AuditApproveRequest: MessageFns<AuditApproveRequest> = {
  encode(message: AuditApproveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditApproveRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditApproveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditApproveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditApproveRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditApproveRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditApproveRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditApproveRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditApproveRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditApproveRequest>, I>>(base?: I): AuditApproveRequest {
    return AuditApproveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditApproveRequest>, I>>(object: I): AuditApproveRequest {
    const message = createBaseAuditApproveRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditApproveRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditApproveRequestBody(): AuditApproveRequestBody {
  return { metadata: undefined };
}

export const AuditApproveRequestBody: MessageFns<AuditApproveRequestBody> = {
  encode(message: AuditApproveRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      CommentMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditApproveRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditApproveRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = CommentMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditApproveRequestBody {
    return { metadata: isSet(object.metadata) ? CommentMetadata.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: AuditApproveRequestBody): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = CommentMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditApproveRequestBody>, I>>(base?: I): AuditApproveRequestBody {
    return AuditApproveRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditApproveRequestBody>, I>>(object: I): AuditApproveRequestBody {
    const message = createBaseAuditApproveRequestBody();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CommentMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAuditApproveResponse(): AuditApproveResponse {
  return { header: undefined, body: undefined };
}

export const AuditApproveResponse: MessageFns<AuditApproveResponse> = {
  encode(message: AuditApproveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditApproveResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditApproveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditApproveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditApproveResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditApproveResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditApproveResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditApproveResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditApproveResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditApproveResponse>, I>>(base?: I): AuditApproveResponse {
    return AuditApproveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditApproveResponse>, I>>(object: I): AuditApproveResponse {
    const message = createBaseAuditApproveResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditApproveResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditApproveResponseBody(): AuditApproveResponseBody {
  return { status: undefined, metadata: undefined };
}

export const AuditApproveResponseBody: MessageFns<AuditApproveResponseBody> = {
  encode(message: AuditApproveResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      CommentMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditApproveResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditApproveResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = CommentMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditApproveResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      metadata: isSet(object.metadata) ? CommentMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AuditApproveResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = CommentMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditApproveResponseBody>, I>>(base?: I): AuditApproveResponseBody {
    return AuditApproveResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditApproveResponseBody>, I>>(object: I): AuditApproveResponseBody {
    const message = createBaseAuditApproveResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CommentMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAuditRejectRequest(): AuditRejectRequest {
  return { header: undefined, body: undefined };
}

export const AuditRejectRequest: MessageFns<AuditRejectRequest> = {
  encode(message: AuditRejectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditRejectRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditRejectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditRejectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditRejectRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditRejectRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditRejectRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditRejectRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditRejectRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditRejectRequest>, I>>(base?: I): AuditRejectRequest {
    return AuditRejectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditRejectRequest>, I>>(object: I): AuditRejectRequest {
    const message = createBaseAuditRejectRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditRejectRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditRejectRequestBody(): AuditRejectRequestBody {
  return { metadata: undefined };
}

export const AuditRejectRequestBody: MessageFns<AuditRejectRequestBody> = {
  encode(message: AuditRejectRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      CommentMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditRejectRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditRejectRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = CommentMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditRejectRequestBody {
    return { metadata: isSet(object.metadata) ? CommentMetadata.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: AuditRejectRequestBody): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = CommentMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditRejectRequestBody>, I>>(base?: I): AuditRejectRequestBody {
    return AuditRejectRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditRejectRequestBody>, I>>(object: I): AuditRejectRequestBody {
    const message = createBaseAuditRejectRequestBody();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CommentMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAuditRejectResponse(): AuditRejectResponse {
  return { header: undefined, body: undefined };
}

export const AuditRejectResponse: MessageFns<AuditRejectResponse> = {
  encode(message: AuditRejectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditRejectResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditRejectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditRejectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditRejectResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditRejectResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditRejectResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditRejectResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditRejectResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditRejectResponse>, I>>(base?: I): AuditRejectResponse {
    return AuditRejectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditRejectResponse>, I>>(object: I): AuditRejectResponse {
    const message = createBaseAuditRejectResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditRejectResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditRejectResponseBody(): AuditRejectResponseBody {
  return { status: undefined, metadata: undefined };
}

export const AuditRejectResponseBody: MessageFns<AuditRejectResponseBody> = {
  encode(message: AuditRejectResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      CommentMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditRejectResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditRejectResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = CommentMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditRejectResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      metadata: isSet(object.metadata) ? CommentMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AuditRejectResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = CommentMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditRejectResponseBody>, I>>(base?: I): AuditRejectResponseBody {
    return AuditRejectResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditRejectResponseBody>, I>>(object: I): AuditRejectResponseBody {
    const message = createBaseAuditRejectResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CommentMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAuditSearchRequest(): AuditSearchRequest {
  return { header: undefined, body: undefined };
}

export const AuditSearchRequest: MessageFns<AuditSearchRequest> = {
  encode(message: AuditSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditSearchRequestBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditSearchRequestBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditSearchRequest {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditSearchRequestBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditSearchRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditSearchRequestBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditSearchRequest>, I>>(base?: I): AuditSearchRequest {
    return AuditSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditSearchRequest>, I>>(object: I): AuditSearchRequest {
    const message = createBaseAuditSearchRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditSearchRequestBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditSearchRequestBody(): AuditSearchRequestBody {
  return { condition: undefined, page: undefined };
}

export const AuditSearchRequestBody: MessageFns<AuditSearchRequestBody> = {
  encode(message: AuditSearchRequestBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== undefined) {
      AuditSearchCondition.encode(message.condition, writer.uint32(10).fork()).join();
    }
    if (message.page !== undefined) {
      RequestPage.encode(message.page, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditSearchRequestBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditSearchRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.condition = AuditSearchCondition.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.page = RequestPage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditSearchRequestBody {
    return {
      condition: isSet(object.condition) ? AuditSearchCondition.fromJSON(object.condition) : undefined,
      page: isSet(object.page) ? RequestPage.fromJSON(object.page) : undefined,
    };
  },

  toJSON(message: AuditSearchRequestBody): unknown {
    const obj: any = {};
    if (message.condition !== undefined) {
      obj.condition = AuditSearchCondition.toJSON(message.condition);
    }
    if (message.page !== undefined) {
      obj.page = RequestPage.toJSON(message.page);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditSearchRequestBody>, I>>(base?: I): AuditSearchRequestBody {
    return AuditSearchRequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditSearchRequestBody>, I>>(object: I): AuditSearchRequestBody {
    const message = createBaseAuditSearchRequestBody();
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? AuditSearchCondition.fromPartial(object.condition)
      : undefined;
    message.page = (object.page !== undefined && object.page !== null)
      ? RequestPage.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseAuditSearchResponse(): AuditSearchResponse {
  return { header: undefined, body: undefined };
}

export const AuditSearchResponse: MessageFns<AuditSearchResponse> = {
  encode(message: AuditSearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      AuditSearchResponseBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditSearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AuditSearchResponseBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditSearchResponse {
    return {
      header: isSet(object.header) ? MessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? AuditSearchResponseBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: AuditSearchResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MessageHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = AuditSearchResponseBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditSearchResponse>, I>>(base?: I): AuditSearchResponse {
    return AuditSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditSearchResponse>, I>>(object: I): AuditSearchResponse {
    const message = createBaseAuditSearchResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? MessageHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? AuditSearchResponseBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseAuditSearchResponseBody(): AuditSearchResponseBody {
  return { status: undefined, detail: [], page: undefined };
}

export const AuditSearchResponseBody: MessageFns<AuditSearchResponseBody> = {
  encode(message: AuditSearchResponseBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      ResponseStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.detail) {
      AuditDetail.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.page !== undefined) {
      ResponsePage.encode(message.page, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditSearchResponseBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditSearchResponseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = ResponseStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.detail.push(AuditDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.page = ResponsePage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditSearchResponseBody {
    return {
      status: isSet(object.status) ? ResponseStatus.fromJSON(object.status) : undefined,
      detail: globalThis.Array.isArray(object?.detail) ? object.detail.map((e: any) => AuditDetail.fromJSON(e)) : [],
      page: isSet(object.page) ? ResponsePage.fromJSON(object.page) : undefined,
    };
  },

  toJSON(message: AuditSearchResponseBody): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = ResponseStatus.toJSON(message.status);
    }
    if (message.detail?.length) {
      obj.detail = message.detail.map((e) => AuditDetail.toJSON(e));
    }
    if (message.page !== undefined) {
      obj.page = ResponsePage.toJSON(message.page);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditSearchResponseBody>, I>>(base?: I): AuditSearchResponseBody {
    return AuditSearchResponseBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditSearchResponseBody>, I>>(object: I): AuditSearchResponseBody {
    const message = createBaseAuditSearchResponseBody();
    message.status = (object.status !== undefined && object.status !== null)
      ? ResponseStatus.fromPartial(object.status)
      : undefined;
    message.detail = object.detail?.map((e) => AuditDetail.fromPartial(e)) || [];
    message.page = (object.page !== undefined && object.page !== null)
      ? ResponsePage.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseAuditDetail(): AuditDetail {
  return { meta: undefined, commentMeta: [] };
}

export const AuditDetail: MessageFns<AuditDetail> = {
  encode(message: AuditDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      AuditMetadata.encode(message.meta, writer.uint32(10).fork()).join();
    }
    for (const v of message.commentMeta) {
      CommentMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meta = AuditMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commentMeta.push(CommentMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditDetail {
    return {
      meta: isSet(object.meta) ? AuditMetadata.fromJSON(object.meta) : undefined,
      commentMeta: globalThis.Array.isArray(object?.commentMeta)
        ? object.commentMeta.map((e: any) => CommentMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AuditDetail): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = AuditMetadata.toJSON(message.meta);
    }
    if (message.commentMeta?.length) {
      obj.commentMeta = message.commentMeta.map((e) => CommentMetadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditDetail>, I>>(base?: I): AuditDetail {
    return AuditDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditDetail>, I>>(object: I): AuditDetail {
    const message = createBaseAuditDetail();
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? AuditMetadata.fromPartial(object.meta)
      : undefined;
    message.commentMeta = object.commentMeta?.map((e) => CommentMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAuditSearchCondition(): AuditSearchCondition {
  return { approver: "", name: "", type: "", applicant: "", startTime: "", endTime: "" };
}

export const AuditSearchCondition: MessageFns<AuditSearchCondition> = {
  encode(message: AuditSearchCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approver !== "") {
      writer.uint32(10).string(message.approver);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.applicant !== "") {
      writer.uint32(34).string(message.applicant);
    }
    if (message.startTime !== "") {
      writer.uint32(42).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(50).string(message.endTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditSearchCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditSearchCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.approver = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.applicant = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditSearchCondition {
    return {
      approver: isSet(object.approver) ? globalThis.String(object.approver) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      applicant: isSet(object.applicant) ? globalThis.String(object.applicant) : "",
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
    };
  },

  toJSON(message: AuditSearchCondition): unknown {
    const obj: any = {};
    if (message.approver !== "") {
      obj.approver = message.approver;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.applicant !== "") {
      obj.applicant = message.applicant;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditSearchCondition>, I>>(base?: I): AuditSearchCondition {
    return AuditSearchCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditSearchCondition>, I>>(object: I): AuditSearchCondition {
    const message = createBaseAuditSearchCondition();
    message.approver = object.approver ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.applicant = object.applicant ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    return message;
  },
};

function createBaseAuditMetadata(): AuditMetadata {
  return {
    uid: "",
    appOrServiceMetadata: "",
    auditType: "",
    applicant: "",
    approver: "",
    reason: "",
    createdAt: "",
    updatedAt: "",
    signature: "",
  };
}

export const AuditMetadata: MessageFns<AuditMetadata> = {
  encode(message: AuditMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.appOrServiceMetadata !== "") {
      writer.uint32(18).string(message.appOrServiceMetadata);
    }
    if (message.applicant !== "") {
      writer.uint32(26).string(message.applicant);
    }
    if (message.approver !== "") {
      writer.uint32(42).string(message.approver);
    }
    if (message.reason !== "") {
      writer.uint32(58).string(message.reason);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    if (message.signature !== "") {
      writer.uint32(90).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appOrServiceMetadata = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.applicant = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.approver = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditMetadata {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      appOrServiceMetadata: isSet(object.appOrServiceMetadata) ? globalThis.String(object.appOrServiceMetadata) : "",
      auditType: isSet(object.auditType) ? globalThis.String(object.auditType) : "",
      applicant: isSet(object.applicant) ? globalThis.String(object.applicant) : "",
      approver: isSet(object.approver) ? globalThis.String(object.approver) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
    };
  },

  toJSON(message: AuditMetadata): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.appOrServiceMetadata !== "") {
      obj.appOrServiceMetadata = message.appOrServiceMetadata;
    }
    if (message.applicant !== "") {
      obj.applicant = message.applicant;
    }
    if (message.approver !== "") {
      obj.approver = message.approver;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditMetadata>, I>>(base?: I): AuditMetadata {
    return AuditMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditMetadata>, I>>(object: I): AuditMetadata {
    const message = createBaseAuditMetadata();
    message.uid = object.uid ?? "";
    message.appOrServiceMetadata = object.appOrServiceMetadata ?? "";
    message.applicant = object.applicant ?? "";
    message.approver = object.approver ?? "";
    message.reason = object.reason ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseCommentMetadata(): CommentMetadata {
  return { uid: "", auditId: "", text: "", status: 0, createdAt: "", updatedAt: "", signature: "" };
}

export const CommentMetadata: MessageFns<CommentMetadata> = {
  encode(message: CommentMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.auditId !== "") {
      writer.uint32(18).string(message.auditId);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    if (message.signature !== "") {
      writer.uint32(58).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.auditId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommentMetadata {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      auditId: isSet(object.auditId) ? globalThis.String(object.auditId) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      status: isSet(object.status) ? commentStatusEnumFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
    };
  },

  toJSON(message: CommentMetadata): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.auditId !== "") {
      obj.auditId = message.auditId;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.status !== 0) {
      obj.status = commentStatusEnumToJSON(message.status);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommentMetadata>, I>>(base?: I): CommentMetadata {
    return CommentMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommentMetadata>, I>>(object: I): CommentMetadata {
    const message = createBaseCommentMetadata();
    message.uid = object.uid ?? "";
    message.auditId = object.auditId ?? "";
    message.text = object.text ?? "";
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.signature = object.signature ?? "";
    return message;
  },
};

/**
 * 审批服务
 * 发起应用访问申请->
 * 查看审批详情->
 */
export type AuditService = typeof AuditService;
export const AuditService = {
  /** 发起申请 */
  create: {
    path: "/yeying.api.audit.Audit/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuditCreateRequest) => Buffer.from(AuditCreateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuditCreateRequest.decode(value),
    responseSerialize: (value: AuditCreateResponse) => Buffer.from(AuditCreateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuditCreateResponse.decode(value),
  },
  /** 查看申请详情 */
  detail: {
    path: "/yeying.api.audit.Audit/Detail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuditDetailRequest) => Buffer.from(AuditDetailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuditDetailRequest.decode(value),
    responseSerialize: (value: AuditDetailResponse) => Buffer.from(AuditDetailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuditDetailResponse.decode(value),
  },
  /** 撤销申请 */
  cancel: {
    path: "/yeying.api.audit.Audit/Cancel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuditCancelRequest) => Buffer.from(AuditCancelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuditCancelRequest.decode(value),
    responseSerialize: (value: AuditCancelResponse) => Buffer.from(AuditCancelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuditCancelResponse.decode(value),
  },
  /** 通过 */
  approve: {
    path: "/yeying.api.audit.Audit/Approve",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuditApproveRequest) => Buffer.from(AuditApproveRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuditApproveRequest.decode(value),
    responseSerialize: (value: AuditApproveResponse) => Buffer.from(AuditApproveResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuditApproveResponse.decode(value),
  },
  /** 拒绝 */
  reject: {
    path: "/yeying.api.audit.Audit/Reject",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuditRejectRequest) => Buffer.from(AuditRejectRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuditRejectRequest.decode(value),
    responseSerialize: (value: AuditRejectResponse) => Buffer.from(AuditRejectResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuditRejectResponse.decode(value),
  },
  /** 列表 */
  search: {
    path: "/yeying.api.audit.Audit/Search",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuditSearchRequest) => Buffer.from(AuditSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuditSearchRequest.decode(value),
    responseSerialize: (value: AuditSearchResponse) => Buffer.from(AuditSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuditSearchResponse.decode(value),
  },
} as const;

export interface AuditServer extends UntypedServiceImplementation {
  /** 发起申请 */
  create: handleUnaryCall<AuditCreateRequest, AuditCreateResponse>;
  /** 查看申请详情 */
  detail: handleUnaryCall<AuditDetailRequest, AuditDetailResponse>;
  /** 撤销申请 */
  cancel: handleUnaryCall<AuditCancelRequest, AuditCancelResponse>;
  /** 通过 */
  approve: handleUnaryCall<AuditApproveRequest, AuditApproveResponse>;
  /** 拒绝 */
  reject: handleUnaryCall<AuditRejectRequest, AuditRejectResponse>;
  /** 列表 */
  search: handleUnaryCall<AuditSearchRequest, AuditSearchResponse>;
}

export interface AuditClient extends Client {
  /** 发起申请 */
  create(
    request: AuditCreateRequest,
    callback: (error: ServiceError | null, response: AuditCreateResponse) => void,
  ): ClientUnaryCall;
  create(
    request: AuditCreateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuditCreateResponse) => void,
  ): ClientUnaryCall;
  create(
    request: AuditCreateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuditCreateResponse) => void,
  ): ClientUnaryCall;
  /** 查看申请详情 */
  detail(
    request: AuditDetailRequest,
    callback: (error: ServiceError | null, response: AuditDetailResponse) => void,
  ): ClientUnaryCall;
  detail(
    request: AuditDetailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuditDetailResponse) => void,
  ): ClientUnaryCall;
  detail(
    request: AuditDetailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuditDetailResponse) => void,
  ): ClientUnaryCall;
  /** 撤销申请 */
  cancel(
    request: AuditCancelRequest,
    callback: (error: ServiceError | null, response: AuditCancelResponse) => void,
  ): ClientUnaryCall;
  cancel(
    request: AuditCancelRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuditCancelResponse) => void,
  ): ClientUnaryCall;
  cancel(
    request: AuditCancelRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuditCancelResponse) => void,
  ): ClientUnaryCall;
  /** 通过 */
  approve(
    request: AuditApproveRequest,
    callback: (error: ServiceError | null, response: AuditApproveResponse) => void,
  ): ClientUnaryCall;
  approve(
    request: AuditApproveRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuditApproveResponse) => void,
  ): ClientUnaryCall;
  approve(
    request: AuditApproveRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuditApproveResponse) => void,
  ): ClientUnaryCall;
  /** 拒绝 */
  reject(
    request: AuditRejectRequest,
    callback: (error: ServiceError | null, response: AuditRejectResponse) => void,
  ): ClientUnaryCall;
  reject(
    request: AuditRejectRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuditRejectResponse) => void,
  ): ClientUnaryCall;
  reject(
    request: AuditRejectRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuditRejectResponse) => void,
  ): ClientUnaryCall;
  /** 列表 */
  search(
    request: AuditSearchRequest,
    callback: (error: ServiceError | null, response: AuditSearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: AuditSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuditSearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: AuditSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuditSearchResponse) => void,
  ): ClientUnaryCall;
}

export const AuditClient = makeGenericClientConstructor(AuditService, "yeying.api.audit.Audit") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuditClient;
  service: typeof AuditService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
